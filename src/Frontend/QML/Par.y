-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Frontend.QML.Par where
import Frontend.QML.Abs
import Frontend.QML.Lex
import Frontend.QML.ErrM

}

%name pProgram Program
%name pListToplevel ListToplevel
%name pToplevel Toplevel
%name pListArg ListArg
%name pArg Arg
%name pTypedVar TypedVar
%name pListTypedVar ListTypedVar
%name pExpr3 Expr3
%name pExpr2 Expr2
%name pExpr1 Expr1
%name pExpr Expr
%name pListExpr ListExpr
%name pLet Let
%name pListLet ListLet
%name pComplex Complex
%name pPattern Pattern
%name pType2 Type2
%name pType1 Type1
%name pType Type
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '*' { PT _ (TS _ 3) }
  '+' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '->' { PT _ (TS _ 6) }
  '-j' { PT _ (TS _ 7) }
  ':' { PT _ (TS _ 8) }
  ':=' { PT _ (TS _ 9) }
  ';' { PT _ (TS _ 10) }
  '=' { PT _ (TS _ 11) }
  '[' { PT _ (TS _ 12) }
  ']' { PT _ (TS _ 13) }
  'def' { PT _ (TS _ 14) }
  'else' { PT _ (TS _ 15) }
  'end' { PT _ (TS _ 16) }
  'if' { PT _ (TS _ 17) }
  'if*' { PT _ (TS _ 18) }
  'if°' { PT _ (TS _ 19) }
  'in' { PT _ (TS _ 20) }
  'j' { PT _ (TS _ 21) }
  'let' { PT _ (TS _ 22) }
  'qubit' { PT _ (TS _ 23) }
  'then' { PT _ (TS _ 24) }
  'unit' { PT _ (TS _ 25) }
  '{' { PT _ (TS _ 26) }
  '}' { PT _ (TS _ 27) }
  '~+' { PT _ (TS _ 28) }
  '~-' { PT _ (TS _ 29) }
  '~0' { PT _ (TS _ 30) }
  '~1' { PT _ (TS _ 31) }
  '~i' { PT _ (TS _ 32) }
  '~j' { PT _ (TS _ 33) }
  L_ident  { PT _ (TV $$) }
  L_Scalar { PT _ (T_Scalar $$) }

%%

Ident   :: { Ident }
Ident    : L_ident  { Ident $1 }

Scalar :: { Scalar}
Scalar  : L_Scalar { Scalar ($1)}

Program :: { Program }
Program : ListToplevel { Frontend.QML.Abs.Progr (reverse $1) }
ListToplevel :: { [Toplevel] }
ListToplevel : {- empty -} { [] }
             | ListToplevel Toplevel 'end' { flip (:) $1 $2 }
Toplevel :: { Toplevel }
Toplevel : 'def' Ident ListArg ':=' Expr { Frontend.QML.Abs.ToplF $2 (reverse $3) $5 }
         | 'def' Ident ListArg '->' Type ':=' Expr { Frontend.QML.Abs.ToplFT $2 (reverse $3) $5 $7 }
ListArg :: { [Arg] }
ListArg : {- empty -} { [] } | ListArg Arg { flip (:) $1 $2 }
Arg :: { Arg }
Arg : '(' ListTypedVar ')' { Frontend.QML.Abs.ArgTup $2 }
TypedVar :: { TypedVar }
TypedVar : Ident ':' Type { Frontend.QML.Abs.TVar $1 $3 }
ListTypedVar :: { [TypedVar] }
ListTypedVar : TypedVar { (:[]) $1 }
             | TypedVar ',' ListTypedVar { (:) $1 $3 }
Expr3 :: { Expr }
Expr3 : Ident { Frontend.QML.Abs.EVar $1 }
      | '~1' { Frontend.QML.Abs.ETrue }
      | '~0' { Frontend.QML.Abs.EFalse }
      | '~+' { qplus_ }
      | '~-' { qminus_ }
      | '~i' { qimagi_ }
      | '~j' { qimagj_ }
      | '(' ListExpr ')' { Frontend.QML.Abs.ETup $2 }
      | '[' Complex ']' Expr3 { Frontend.QML.Abs.EMul $2 $4 }
      | '(' Expr ')' { $2 }
Expr2 :: { Expr }
Expr2 : Expr2 Expr3 { Frontend.QML.Abs.EApp $1 $2 } | Expr3 { $1 }
Expr1 :: { Expr }
Expr1 : Expr2 '+' Expr1 { Frontend.QML.Abs.EPlus $1 $3 }
      | 'if°' Expr 'then' Expr 'else' Expr { Frontend.QML.Abs.EIfq $2 $4 $6 }
      | 'if*' Expr 'then' Expr 'else' Expr { eifq_ $2 $4 $6 }
      | 'if' Expr 'then' Expr 'else' Expr { Frontend.QML.Abs.EIf $2 $4 $6 }
      | 'let' '{' ListLet '}' 'in' Expr { Frontend.QML.Abs.ELet $3 $6 }
      | Expr2 { $1 }
Expr :: { Expr }
Expr : Expr1 { $1 }
ListExpr :: { [Expr] }
ListExpr : {- empty -} { [] }
         | Expr { (:[]) $1 }
         | Expr ',' ListExpr { (:) $1 $3 }
Let :: { Let }
Let : Pattern '=' Expr { Frontend.QML.Abs.LLet $1 $3 }
ListLet :: { [Let] }
ListLet : Let { (:[]) $1 } | Let ';' ListLet { (:) $1 $3 }
Complex :: { Complex }
Complex : Scalar '+' Scalar 'j' { Frontend.QML.Abs.CComp $1 $3 }
        | Scalar { creal_ $1 }
        | Scalar 'j' { cimag_ $1 }
        | '-j' { cnmag_ }
        | 'j' { cjmag_ }
Pattern :: { Pattern }
Pattern : Ident { Frontend.QML.Abs.PVar $1 }
        | '(' Ident ',' Ident ')' { Frontend.QML.Abs.PTup $2 $4 }
Type2 :: { Type }
Type2 : 'qubit' { Frontend.QML.Abs.TQubit }
      | 'unit' { Frontend.QML.Abs.TUnit }
      | '(' Type ')' { $2 }
Type1 :: { Type }
Type1 : Type2 '*' Type1 { Frontend.QML.Abs.TTens $1 $3 }
      | Type2 { $1 }
Type :: { Type }
Type : Type1 { $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
qplus_ = EPlus ETrue EFalse
qminus_ = EPlus (EMul (CComp (Scalar "-1") (Scalar "0")) ETrue) EFalse
qimagi_ = EMul (CComp (Scalar "0") (Scalar "1")) ETrue
qimagj_ = EMul (CComp (Scalar "0") (Scalar "-1")) EFalse
eifq_ c_ t_ f_ = EIfq c_ t_ f_
creal_ r_ = CComp r_ (Scalar "0")
cimag_ i_ = CComp (Scalar "0") i_
cnmag_ = CComp (Scalar "0") (Scalar "-1")
cjmag_ = CComp (Scalar "0") (Scalar "1")
}

